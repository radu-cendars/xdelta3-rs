/* automatically generated by rust-bindgen 0.72.1 */

pub type usize_t = u32;
pub type xoff_t = u64;
#[doc = " The primary xd3_stream object, used for encoding and decoding.  You\n may access only two fields: avail_out, next_out.  Use the methods\n above to operate on xd3_stream."]
pub type xd3_stream = _xd3_stream;
#[doc = " The primary source file object. You create one of these objects and\n initialize the first four fields.  This library maintains the next\n 5 fields.  The configured getblk implementation is responsible for\n setting the final 3 fields when called (and/or when XD3_GETSRCBLK\n is returned)."]
pub type xd3_source = _xd3_source;
#[doc = " hash table size & power-of-two hash function."]
pub type xd3_hash_cfg = _xd3_hash_cfg;
#[doc = " This is the record of a pre-compiled configuration, a subset of\nxd3_config."]
pub type xd3_smatcher = _xd3_smatcher;
#[doc = " the raw encoding of an instruction used in the IOPT buffer"]
pub type xd3_rinst = _xd3_rinst;
#[doc = " the code-table form of an single- or double-instruction"]
pub type xd3_dinst = _xd3_dinst;
#[doc = " the decoded form of a single (half) instruction."]
pub type xd3_hinst = _xd3_hinst;
#[doc = " the form of a whole-file instruction"]
pub type xd3_winst = _xd3_winst;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_rpage {
    _unused: [u8; 0],
}
pub type xd3_rpage = _xd3_rpage;
#[doc = " the VCDIFF address cache, see the RFC"]
pub type xd3_addr_cache = _xd3_addr_cache;
#[doc = " used by the encoder to buffer output in sections.  list of blocks."]
pub type xd3_output = _xd3_output;
#[doc = " used by the decoder to buffer input in sections."]
pub type xd3_desect = _xd3_desect;
#[doc = " the IOPT buffer list is just a list of buffers, which may be allocated\n during encode when using an unlimited buffer."]
pub type xd3_iopt_buflist = _xd3_iopt_buflist;
#[doc = " instruction lists used in the IOPT buffer"]
pub type xd3_rlist = _xd3_rlist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_sec_type {
    _unused: [u8; 0],
}
pub type xd3_sec_type = _xd3_sec_type;
#[doc = " Settings for the secondary compressor."]
pub type xd3_sec_cfg = _xd3_sec_cfg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_sec_stream {
    _unused: [u8; 0],
}
pub type xd3_sec_stream = _xd3_sec_stream;
#[doc = " This is the user-visible stream configuration."]
pub type xd3_config = _xd3_config;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_code_table_desc {
    _unused: [u8; 0],
}
pub type xd3_code_table_desc = _xd3_code_table_desc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_code_table_sizes {
    _unused: [u8; 0],
}
pub type xd3_code_table_sizes = _xd3_code_table_sizes;
#[doc = " the sprev list"]
pub type xd3_slist = _xd3_slist;
#[doc = " whole state for, e.g., merge"]
pub type xd3_whole_state = _xd3_whole_state;
#[doc = " window info (for whole state)"]
pub type xd3_wininfo = _xd3_wininfo;
#[doc = " The stream configuration has three callbacks functions, all of\n which may be supplied with NULL values.  If config->getblk is\n provided as NULL, the stream returns XD3_GETSRCBLK."]
pub type xd3_alloc_func = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        items: usize,
        size: usize_t,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type xd3_free_func = ::std::option::Option<
    unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, address: *mut ::std::os::raw::c_void),
>;
pub type xd3_getblk_func = ::std::option::Option<
    unsafe extern "C" fn(
        stream: *mut xd3_stream,
        source: *mut xd3_source,
        blkno: xoff_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " These are internal functions to delay construction of encoding\n tables and support alternate code tables.  See the comments & code\n enabled by GENERIC_ENCODE_TABLES."]
pub type xd3_code_table_func = ::std::option::Option<unsafe extern "C" fn() -> *const xd3_dinst>;
pub type xd3_comp_table_func = ::std::option::Option<
    unsafe extern "C" fn(
        stream: *mut xd3_stream,
        data: *mut *const u8,
        size: *mut usize_t,
    ) -> ::std::os::raw::c_int,
>;
#[repr(i32)]
#[doc = " These are the five ordinary status codes returned by the\n xd3_encode_input() and xd3_decode_input() state machines."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum xd3_rvalues {
    #[doc = " need input"]
    XD3_INPUT = -17703,
    #[doc = " have output"]
    XD3_OUTPUT = -17704,
    #[doc = " need a block of source input (with no\n xd3_getblk function), a chance to do\n non-blocking read."]
    XD3_GETSRCBLK = -17705,
    #[doc = " (decode-only) after the initial VCDIFF &\nfirst window header"]
    XD3_GOTHEADER = -17706,
    #[doc = " notification: returned before a window is\n processed, giving a chance to\n XD3_SKIP_WINDOW or not XD3_SKIP_EMIT that\n window."]
    XD3_WINSTART = -17707,
    #[doc = " notification: returned after\nencode/decode & output for a window"]
    XD3_WINFINISH = -17708,
    #[doc = " (encoder only) may be returned by\ngetblk() if the block is too old"]
    XD3_TOOFARBACK = -17709,
    #[doc = " internal error"]
    XD3_INTERNAL = -17710,
    #[doc = " invalid config"]
    XD3_INVALID = -17711,
    #[doc = " invalid input/decoder error"]
    XD3_INVALID_INPUT = -17712,
    #[doc = " when secondary compression finds no\nimprovement."]
    XD3_NOSECOND = -17713,
    #[doc = " currently VCD_TARGET, VCD_CODETABLE"]
    XD3_UNIMPLEMENTED = -17714,
}
#[repr(i32)]
#[doc = " special values in config->flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum xd3_flags {
    #[doc = " used by VCDIFF tools, see\nxdelta3-main.h."]
    XD3_JUST_HDR = 2,
    #[doc = " used by VCDIFF tools, see\nxdelta3-main.h."]
    XD3_SKIP_WINDOW = 4,
    #[doc = " used by VCDIFF tools, see\nxdelta3-main.h."]
    XD3_SKIP_EMIT = 8,
    #[doc = " flush the stream buffer to\nprepare for\nxd3_stream_close()."]
    XD3_FLUSH = 16,
    #[doc = " use DJW static huffman"]
    XD3_SEC_DJW = 32,
    #[doc = " use FGK adaptive huffman"]
    XD3_SEC_FGK = 64,
    #[doc = " use LZMA secondary"]
    XD3_SEC_LZMA = 16777216,
    XD3_SEC_TYPE = 16777312,
    #[doc = " disable secondary compression of\nthe data section."]
    XD3_SEC_NODATA = 128,
    #[doc = " disable secondary compression of\nthe inst section."]
    XD3_SEC_NOINST = 256,
    #[doc = " disable secondary compression of\nthe addr section."]
    XD3_SEC_NOADDR = 512,
    XD3_SEC_NOALL = 896,
    #[doc = " enable checksum computation in\nthe encoder."]
    XD3_ADLER32 = 1024,
    #[doc = " disable checksum verification in\nthe decoder."]
    XD3_ADLER32_NOVER = 2048,
    #[doc = " disable ordinary data\n compression feature, only search\n the source, not the target."]
    XD3_NOCOMPRESS = 8192,
    #[doc = " disable the \"1.5-pass\n algorithm\", instead use greedy\n matching.  Greedy is off by\n default."]
    XD3_BEGREEDY = 16384,
    #[doc = " used by \"recode\"."]
    XD3_ADLER32_RECODE = 32768,
    #[doc = " 20 - 23"]
    XD3_COMPLEVEL_SHIFT = 20,
    XD3_COMPLEVEL_MASK = 15728640,
    XD3_COMPLEVEL_1 = 1048576,
    XD3_COMPLEVEL_2 = 2097152,
    XD3_COMPLEVEL_3 = 3145728,
    XD3_COMPLEVEL_6 = 6291456,
    XD3_COMPLEVEL_9 = 9437184,
}
#[repr(i32)]
#[doc = " The values of this enumeration are set in xd3_config using the\n smatch_cfg variable.  It can be set to default, slow, fast, etc.,\n and soft."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum xd3_smatch_cfg {
    #[doc = " Flags may contain XD3_COMPLEVEL bits,\nelse default."]
    XD3_SMATCH_DEFAULT = 0,
    XD3_SMATCH_SLOW = 1,
    XD3_SMATCH_FAST = 2,
    XD3_SMATCH_FASTER = 3,
    XD3_SMATCH_FASTEST = 4,
    XD3_SMATCH_SOFT = 5,
}
#[repr(i32)]
#[doc = " stream->match_state is part of the xd3_encode_input state machine\n  for source matching:\n\n  1. the XD3_GETSRCBLK block-read mechanism means reentrant matching\n  2. this state spans encoder windows: a match and end-of-window\n  will continue in the next 3. the initial target byte and source\n  byte are a presumed match, to avoid some computation in case the\n  inputs are identical."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum xd3_match_state {
    #[doc = " in this state, attempt to match the start of\n the target with the previously set source\n address (initially 0)."]
    MATCH_TARGET = 0,
    #[doc = " currently expanding a match backward in the\nsource/target."]
    MATCH_BACKWARD = 1,
    #[doc = " currently expanding a match forward in the\nsource/target."]
    MATCH_FORWARD = 2,
    #[doc = " currently searching for a match."]
    MATCH_SEARCHING = 3,
}
#[repr(i32)]
#[doc = " The xd3_encode_input state machine steps through these states in\n the following order.  The matcher is reentrant and returns\n XD3_INPUT whenever it requires more data.  After receiving\n XD3_INPUT, if the application reads EOF it should call\n xd3_stream_close()."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum xd3_encode_state {
    #[doc = " xd3_encode_input has never been called."]
    ENC_INIT = 0,
    #[doc = " waiting for xd3_avail_input () to be called."]
    ENC_INPUT = 1,
    #[doc = " currently searching for matches."]
    ENC_SEARCH = 2,
    #[doc = " currently formatting output."]
    ENC_INSTR = 3,
    #[doc = " currently emitting output."]
    ENC_FLUSH = 4,
    #[doc = " after an output section."]
    ENC_POSTOUT = 5,
    #[doc = " after all output sections."]
    ENC_POSTWIN = 6,
    #[doc = " abort."]
    ENC_ABORTED = 7,
}
#[repr(i32)]
#[doc = " The xd3_decode_input state machine steps through these states in\n the following order.  The matcher is reentrant and returns\n XD3_INPUT whenever it requires more data.  After receiving\n XD3_INPUT, if the application reads EOF it should call\n xd3_stream_close().\n\n 0-8:   the VCDIFF header\n 9-18:  the VCDIFF window header\n 19-21: the three primary sections: data, inst, addr\n 22:    producing output: returns XD3_OUTPUT, possibly XD3_GETSRCBLK,\n 23:    return XD3_WINFINISH, set state=9 to decode more input"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum xd3_decode_state {
    #[doc = " VCDIFF header"]
    DEC_VCHEAD = 0,
    #[doc = " header indicator"]
    DEC_HDRIND = 1,
    #[doc = " secondary compressor ID"]
    DEC_SECONDID = 2,
    #[doc = " code table length"]
    DEC_TABLEN = 3,
    #[doc = " code table near"]
    DEC_NEAR = 4,
    #[doc = " code table same"]
    DEC_SAME = 5,
    #[doc = " code table data"]
    DEC_TABDAT = 6,
    #[doc = " application data length"]
    DEC_APPLEN = 7,
    #[doc = " application data"]
    DEC_APPDAT = 8,
    #[doc = " window indicator"]
    DEC_WININD = 9,
    #[doc = " copy window length"]
    DEC_CPYLEN = 10,
    #[doc = " copy window offset"]
    DEC_CPYOFF = 11,
    #[doc = " length of delta encoding"]
    DEC_ENCLEN = 12,
    #[doc = " length of target window"]
    DEC_TGTLEN = 13,
    #[doc = " delta indicator"]
    DEC_DELIND = 14,
    #[doc = " length of ADD+RUN data"]
    DEC_DATALEN = 15,
    #[doc = " length of instruction data"]
    DEC_INSTLEN = 16,
    #[doc = " length of address data"]
    DEC_ADDRLEN = 17,
    #[doc = " window checksum"]
    DEC_CKSUM = 18,
    #[doc = " data section"]
    DEC_DATA = 19,
    #[doc = " instruction section"]
    DEC_INST = 20,
    #[doc = " address section"]
    DEC_ADDR = 21,
    #[doc = " producing data"]
    DEC_EMIT = 22,
    #[doc = " window finished"]
    DEC_FINISH = 23,
    #[doc = " xd3_abort_stream"]
    DEC_ABORTED = 24,
}
#[doc = " instruction lists used in the IOPT buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_rlist {
    pub next: *mut xd3_rlist,
    pub prev: *mut xd3_rlist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_rlist"][::std::mem::size_of::<_xd3_rlist>() - 16usize];
    ["Alignment of _xd3_rlist"][::std::mem::align_of::<_xd3_rlist>() - 8usize];
    ["Offset of field: _xd3_rlist::next"][::std::mem::offset_of!(_xd3_rlist, next) - 0usize];
    ["Offset of field: _xd3_rlist::prev"][::std::mem::offset_of!(_xd3_rlist, prev) - 8usize];
};
#[doc = " the raw encoding of an instruction used in the IOPT buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_rinst {
    pub type_: u8,
    pub xtra: u8,
    pub code1: u8,
    pub code2: u8,
    pub pos: usize_t,
    pub size: usize_t,
    pub addr: xoff_t,
    pub link: xd3_rlist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_rinst"][::std::mem::size_of::<_xd3_rinst>() - 40usize];
    ["Alignment of _xd3_rinst"][::std::mem::align_of::<_xd3_rinst>() - 8usize];
    ["Offset of field: _xd3_rinst::type_"][::std::mem::offset_of!(_xd3_rinst, type_) - 0usize];
    ["Offset of field: _xd3_rinst::xtra"][::std::mem::offset_of!(_xd3_rinst, xtra) - 1usize];
    ["Offset of field: _xd3_rinst::code1"][::std::mem::offset_of!(_xd3_rinst, code1) - 2usize];
    ["Offset of field: _xd3_rinst::code2"][::std::mem::offset_of!(_xd3_rinst, code2) - 3usize];
    ["Offset of field: _xd3_rinst::pos"][::std::mem::offset_of!(_xd3_rinst, pos) - 4usize];
    ["Offset of field: _xd3_rinst::size"][::std::mem::offset_of!(_xd3_rinst, size) - 8usize];
    ["Offset of field: _xd3_rinst::addr"][::std::mem::offset_of!(_xd3_rinst, addr) - 16usize];
    ["Offset of field: _xd3_rinst::link"][::std::mem::offset_of!(_xd3_rinst, link) - 24usize];
};
#[doc = " the code-table form of an single- or double-instruction"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_dinst {
    pub type1: u8,
    pub size1: u8,
    pub type2: u8,
    pub size2: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_dinst"][::std::mem::size_of::<_xd3_dinst>() - 4usize];
    ["Alignment of _xd3_dinst"][::std::mem::align_of::<_xd3_dinst>() - 1usize];
    ["Offset of field: _xd3_dinst::type1"][::std::mem::offset_of!(_xd3_dinst, type1) - 0usize];
    ["Offset of field: _xd3_dinst::size1"][::std::mem::offset_of!(_xd3_dinst, size1) - 1usize];
    ["Offset of field: _xd3_dinst::type2"][::std::mem::offset_of!(_xd3_dinst, type2) - 2usize];
    ["Offset of field: _xd3_dinst::size2"][::std::mem::offset_of!(_xd3_dinst, size2) - 3usize];
};
#[doc = " the decoded form of a single (half) instruction."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_hinst {
    pub type_: u8,
    #[doc = " TODO: why decode breaks if this is usize_t?"]
    pub size: u32,
    #[doc = " TODO: why decode breaks if this is usize_t?"]
    pub addr: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_hinst"][::std::mem::size_of::<_xd3_hinst>() - 12usize];
    ["Alignment of _xd3_hinst"][::std::mem::align_of::<_xd3_hinst>() - 4usize];
    ["Offset of field: _xd3_hinst::type_"][::std::mem::offset_of!(_xd3_hinst, type_) - 0usize];
    ["Offset of field: _xd3_hinst::size"][::std::mem::offset_of!(_xd3_hinst, size) - 4usize];
    ["Offset of field: _xd3_hinst::addr"][::std::mem::offset_of!(_xd3_hinst, addr) - 8usize];
};
#[doc = " the form of a whole-file instruction"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_winst {
    #[doc = " RUN, ADD, COPY"]
    pub type_: u8,
    #[doc = " 0, VCD_SOURCE, VCD_TARGET"]
    pub mode: u8,
    pub size: usize_t,
    pub addr: xoff_t,
    #[doc = " absolute position of this inst"]
    pub position: xoff_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_winst"][::std::mem::size_of::<_xd3_winst>() - 24usize];
    ["Alignment of _xd3_winst"][::std::mem::align_of::<_xd3_winst>() - 8usize];
    ["Offset of field: _xd3_winst::type_"][::std::mem::offset_of!(_xd3_winst, type_) - 0usize];
    ["Offset of field: _xd3_winst::mode"][::std::mem::offset_of!(_xd3_winst, mode) - 1usize];
    ["Offset of field: _xd3_winst::size"][::std::mem::offset_of!(_xd3_winst, size) - 4usize];
    ["Offset of field: _xd3_winst::addr"][::std::mem::offset_of!(_xd3_winst, addr) - 8usize];
    ["Offset of field: _xd3_winst::position"]
        [::std::mem::offset_of!(_xd3_winst, position) - 16usize];
};
#[doc = " used by the encoder to buffer output in sections.  list of blocks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_output {
    pub base: *mut u8,
    pub next: usize_t,
    pub avail: usize_t,
    pub next_page: *mut xd3_output,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_output"][::std::mem::size_of::<_xd3_output>() - 24usize];
    ["Alignment of _xd3_output"][::std::mem::align_of::<_xd3_output>() - 8usize];
    ["Offset of field: _xd3_output::base"][::std::mem::offset_of!(_xd3_output, base) - 0usize];
    ["Offset of field: _xd3_output::next"][::std::mem::offset_of!(_xd3_output, next) - 8usize];
    ["Offset of field: _xd3_output::avail"][::std::mem::offset_of!(_xd3_output, avail) - 12usize];
    ["Offset of field: _xd3_output::next_page"]
        [::std::mem::offset_of!(_xd3_output, next_page) - 16usize];
};
#[doc = " used by the decoder to buffer input in sections."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_desect {
    pub buf: *const u8,
    pub buf_max: *const u8,
    #[doc = " TODO: why decode breaks if this is usize_t?"]
    pub size: u32,
    pub pos: usize_t,
    #[doc = " used in xdelta3-decode.h"]
    pub copied1: *mut u8,
    pub alloc1: usize_t,
    #[doc = " used in xdelta3-second.h"]
    pub copied2: *mut u8,
    pub alloc2: usize_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_desect"][::std::mem::size_of::<_xd3_desect>() - 56usize];
    ["Alignment of _xd3_desect"][::std::mem::align_of::<_xd3_desect>() - 8usize];
    ["Offset of field: _xd3_desect::buf"][::std::mem::offset_of!(_xd3_desect, buf) - 0usize];
    ["Offset of field: _xd3_desect::buf_max"]
        [::std::mem::offset_of!(_xd3_desect, buf_max) - 8usize];
    ["Offset of field: _xd3_desect::size"][::std::mem::offset_of!(_xd3_desect, size) - 16usize];
    ["Offset of field: _xd3_desect::pos"][::std::mem::offset_of!(_xd3_desect, pos) - 20usize];
    ["Offset of field: _xd3_desect::copied1"]
        [::std::mem::offset_of!(_xd3_desect, copied1) - 24usize];
    ["Offset of field: _xd3_desect::alloc1"][::std::mem::offset_of!(_xd3_desect, alloc1) - 32usize];
    ["Offset of field: _xd3_desect::copied2"]
        [::std::mem::offset_of!(_xd3_desect, copied2) - 40usize];
    ["Offset of field: _xd3_desect::alloc2"][::std::mem::offset_of!(_xd3_desect, alloc2) - 48usize];
};
#[doc = " the VCDIFF address cache, see the RFC"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_addr_cache {
    pub s_near: usize_t,
    pub s_same: usize_t,
    #[doc = " the circular index for near"]
    pub next_slot: usize_t,
    #[doc = " array of size s_near"]
    pub near_array: *mut usize_t,
    #[doc = " array of size s_same*256"]
    pub same_array: *mut usize_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_addr_cache"][::std::mem::size_of::<_xd3_addr_cache>() - 32usize];
    ["Alignment of _xd3_addr_cache"][::std::mem::align_of::<_xd3_addr_cache>() - 8usize];
    ["Offset of field: _xd3_addr_cache::s_near"]
        [::std::mem::offset_of!(_xd3_addr_cache, s_near) - 0usize];
    ["Offset of field: _xd3_addr_cache::s_same"]
        [::std::mem::offset_of!(_xd3_addr_cache, s_same) - 4usize];
    ["Offset of field: _xd3_addr_cache::next_slot"]
        [::std::mem::offset_of!(_xd3_addr_cache, next_slot) - 8usize];
    ["Offset of field: _xd3_addr_cache::near_array"]
        [::std::mem::offset_of!(_xd3_addr_cache, near_array) - 16usize];
    ["Offset of field: _xd3_addr_cache::same_array"]
        [::std::mem::offset_of!(_xd3_addr_cache, same_array) - 24usize];
};
#[doc = " the IOPT buffer list is just a list of buffers, which may be allocated\n during encode when using an unlimited buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_iopt_buflist {
    pub buffer: *mut xd3_rinst,
    pub next: *mut xd3_iopt_buflist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_iopt_buflist"][::std::mem::size_of::<_xd3_iopt_buflist>() - 16usize];
    ["Alignment of _xd3_iopt_buflist"][::std::mem::align_of::<_xd3_iopt_buflist>() - 8usize];
    ["Offset of field: _xd3_iopt_buflist::buffer"]
        [::std::mem::offset_of!(_xd3_iopt_buflist, buffer) - 0usize];
    ["Offset of field: _xd3_iopt_buflist::next"]
        [::std::mem::offset_of!(_xd3_iopt_buflist, next) - 8usize];
};
#[doc = " This is the record of a pre-compiled configuration, a subset of\nxd3_config."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_smatcher {
    pub name: *const ::std::os::raw::c_char,
    pub string_match: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut xd3_stream) -> ::std::os::raw::c_int,
    >,
    pub large_look: usize_t,
    pub large_step: usize_t,
    pub small_look: usize_t,
    pub small_chain: usize_t,
    pub small_lchain: usize_t,
    pub max_lazy: usize_t,
    pub long_enough: usize_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_smatcher"][::std::mem::size_of::<_xd3_smatcher>() - 48usize];
    ["Alignment of _xd3_smatcher"][::std::mem::align_of::<_xd3_smatcher>() - 8usize];
    ["Offset of field: _xd3_smatcher::name"][::std::mem::offset_of!(_xd3_smatcher, name) - 0usize];
    ["Offset of field: _xd3_smatcher::string_match"]
        [::std::mem::offset_of!(_xd3_smatcher, string_match) - 8usize];
    ["Offset of field: _xd3_smatcher::large_look"]
        [::std::mem::offset_of!(_xd3_smatcher, large_look) - 16usize];
    ["Offset of field: _xd3_smatcher::large_step"]
        [::std::mem::offset_of!(_xd3_smatcher, large_step) - 20usize];
    ["Offset of field: _xd3_smatcher::small_look"]
        [::std::mem::offset_of!(_xd3_smatcher, small_look) - 24usize];
    ["Offset of field: _xd3_smatcher::small_chain"]
        [::std::mem::offset_of!(_xd3_smatcher, small_chain) - 28usize];
    ["Offset of field: _xd3_smatcher::small_lchain"]
        [::std::mem::offset_of!(_xd3_smatcher, small_lchain) - 32usize];
    ["Offset of field: _xd3_smatcher::max_lazy"]
        [::std::mem::offset_of!(_xd3_smatcher, max_lazy) - 36usize];
    ["Offset of field: _xd3_smatcher::long_enough"]
        [::std::mem::offset_of!(_xd3_smatcher, long_enough) - 40usize];
};
#[doc = " hash table size & power-of-two hash function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_hash_cfg {
    pub size: usize_t,
    pub shift: usize_t,
    pub mask: usize_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_hash_cfg"][::std::mem::size_of::<_xd3_hash_cfg>() - 12usize];
    ["Alignment of _xd3_hash_cfg"][::std::mem::align_of::<_xd3_hash_cfg>() - 4usize];
    ["Offset of field: _xd3_hash_cfg::size"][::std::mem::offset_of!(_xd3_hash_cfg, size) - 0usize];
    ["Offset of field: _xd3_hash_cfg::shift"]
        [::std::mem::offset_of!(_xd3_hash_cfg, shift) - 4usize];
    ["Offset of field: _xd3_hash_cfg::mask"][::std::mem::offset_of!(_xd3_hash_cfg, mask) - 8usize];
};
#[doc = " the sprev list"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_slist {
    pub last_pos: usize_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_slist"][::std::mem::size_of::<_xd3_slist>() - 4usize];
    ["Alignment of _xd3_slist"][::std::mem::align_of::<_xd3_slist>() - 4usize];
    ["Offset of field: _xd3_slist::last_pos"]
        [::std::mem::offset_of!(_xd3_slist, last_pos) - 0usize];
};
#[doc = " window info (for whole state)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_wininfo {
    pub offset: xoff_t,
    pub length: usize_t,
    pub adler32: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_wininfo"][::std::mem::size_of::<_xd3_wininfo>() - 16usize];
    ["Alignment of _xd3_wininfo"][::std::mem::align_of::<_xd3_wininfo>() - 8usize];
    ["Offset of field: _xd3_wininfo::offset"]
        [::std::mem::offset_of!(_xd3_wininfo, offset) - 0usize];
    ["Offset of field: _xd3_wininfo::length"]
        [::std::mem::offset_of!(_xd3_wininfo, length) - 8usize];
    ["Offset of field: _xd3_wininfo::adler32"]
        [::std::mem::offset_of!(_xd3_wininfo, adler32) - 12usize];
};
#[doc = " whole state for, e.g., merge"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_whole_state {
    pub addslen: usize_t,
    pub adds: *mut u8,
    pub adds_alloc: usize_t,
    pub instlen: usize_t,
    pub inst: *mut xd3_winst,
    pub inst_alloc: usize_t,
    pub wininfolen: usize_t,
    pub wininfo: *mut xd3_wininfo,
    pub wininfo_alloc: usize_t,
    pub length: xoff_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_whole_state"][::std::mem::size_of::<_xd3_whole_state>() - 64usize];
    ["Alignment of _xd3_whole_state"][::std::mem::align_of::<_xd3_whole_state>() - 8usize];
    ["Offset of field: _xd3_whole_state::addslen"]
        [::std::mem::offset_of!(_xd3_whole_state, addslen) - 0usize];
    ["Offset of field: _xd3_whole_state::adds"]
        [::std::mem::offset_of!(_xd3_whole_state, adds) - 8usize];
    ["Offset of field: _xd3_whole_state::adds_alloc"]
        [::std::mem::offset_of!(_xd3_whole_state, adds_alloc) - 16usize];
    ["Offset of field: _xd3_whole_state::instlen"]
        [::std::mem::offset_of!(_xd3_whole_state, instlen) - 20usize];
    ["Offset of field: _xd3_whole_state::inst"]
        [::std::mem::offset_of!(_xd3_whole_state, inst) - 24usize];
    ["Offset of field: _xd3_whole_state::inst_alloc"]
        [::std::mem::offset_of!(_xd3_whole_state, inst_alloc) - 32usize];
    ["Offset of field: _xd3_whole_state::wininfolen"]
        [::std::mem::offset_of!(_xd3_whole_state, wininfolen) - 36usize];
    ["Offset of field: _xd3_whole_state::wininfo"]
        [::std::mem::offset_of!(_xd3_whole_state, wininfo) - 40usize];
    ["Offset of field: _xd3_whole_state::wininfo_alloc"]
        [::std::mem::offset_of!(_xd3_whole_state, wininfo_alloc) - 48usize];
    ["Offset of field: _xd3_whole_state::length"]
        [::std::mem::offset_of!(_xd3_whole_state, length) - 56usize];
};
#[doc = " Settings for the secondary compressor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_sec_cfg {
    #[doc = " Which section. (set automatically)"]
    pub data_type: ::std::os::raw::c_int,
    #[doc = " Number of DJW Huffman groups."]
    pub ngroups: usize_t,
    #[doc = " Sector size."]
    pub sector_size: usize_t,
    #[doc = " If true, ignore efficiency check [avoid XD3_NOSECOND]."]
    pub inefficient: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_sec_cfg"][::std::mem::size_of::<_xd3_sec_cfg>() - 16usize];
    ["Alignment of _xd3_sec_cfg"][::std::mem::align_of::<_xd3_sec_cfg>() - 4usize];
    ["Offset of field: _xd3_sec_cfg::data_type"]
        [::std::mem::offset_of!(_xd3_sec_cfg, data_type) - 0usize];
    ["Offset of field: _xd3_sec_cfg::ngroups"]
        [::std::mem::offset_of!(_xd3_sec_cfg, ngroups) - 4usize];
    ["Offset of field: _xd3_sec_cfg::sector_size"]
        [::std::mem::offset_of!(_xd3_sec_cfg, sector_size) - 8usize];
    ["Offset of field: _xd3_sec_cfg::inefficient"]
        [::std::mem::offset_of!(_xd3_sec_cfg, inefficient) - 12usize];
};
#[doc = " This is the user-visible stream configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_config {
    #[doc = " The encoder window size."]
    pub winsize: usize_t,
    #[doc = " How far back small string\nmatching goes"]
    pub sprevsz: usize_t,
    #[doc = " entries in the\ninstruction-optimizing\nbuffer"]
    pub iopt_size: usize_t,
    #[doc = " The three callbacks."]
    pub getblk: xd3_getblk_func,
    pub alloc: xd3_alloc_func,
    pub freef: xd3_free_func,
    #[doc = " Not used."]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " stream->flags are initialized\n from xd3_config & never\n modified by the library.  Use\n xd3_set_flags to modify flags\n settings mid-stream."]
    pub flags: ::std::os::raw::c_int,
    #[doc = " Secondary compressor config: data"]
    pub sec_data: xd3_sec_cfg,
    #[doc = " Secondary compressor config: inst"]
    pub sec_inst: xd3_sec_cfg,
    #[doc = " Secondary compressor config: addr"]
    pub sec_addr: xd3_sec_cfg,
    #[doc = " See enum: use fields below  for\nsoft config"]
    pub smatch_cfg: xd3_smatch_cfg,
    pub smatcher_soft: xd3_smatcher,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_config"][::std::mem::size_of::<_xd3_config>() - 152usize];
    ["Alignment of _xd3_config"][::std::mem::align_of::<_xd3_config>() - 8usize];
    ["Offset of field: _xd3_config::winsize"]
        [::std::mem::offset_of!(_xd3_config, winsize) - 0usize];
    ["Offset of field: _xd3_config::sprevsz"]
        [::std::mem::offset_of!(_xd3_config, sprevsz) - 4usize];
    ["Offset of field: _xd3_config::iopt_size"]
        [::std::mem::offset_of!(_xd3_config, iopt_size) - 8usize];
    ["Offset of field: _xd3_config::getblk"][::std::mem::offset_of!(_xd3_config, getblk) - 16usize];
    ["Offset of field: _xd3_config::alloc"][::std::mem::offset_of!(_xd3_config, alloc) - 24usize];
    ["Offset of field: _xd3_config::freef"][::std::mem::offset_of!(_xd3_config, freef) - 32usize];
    ["Offset of field: _xd3_config::opaque"][::std::mem::offset_of!(_xd3_config, opaque) - 40usize];
    ["Offset of field: _xd3_config::flags"][::std::mem::offset_of!(_xd3_config, flags) - 48usize];
    ["Offset of field: _xd3_config::sec_data"]
        [::std::mem::offset_of!(_xd3_config, sec_data) - 52usize];
    ["Offset of field: _xd3_config::sec_inst"]
        [::std::mem::offset_of!(_xd3_config, sec_inst) - 68usize];
    ["Offset of field: _xd3_config::sec_addr"]
        [::std::mem::offset_of!(_xd3_config, sec_addr) - 84usize];
    ["Offset of field: _xd3_config::smatch_cfg"]
        [::std::mem::offset_of!(_xd3_config, smatch_cfg) - 100usize];
    ["Offset of field: _xd3_config::smatcher_soft"]
        [::std::mem::offset_of!(_xd3_config, smatcher_soft) - 104usize];
};
#[doc = " The primary source file object. You create one of these objects and\n initialize the first four fields.  This library maintains the next\n 5 fields.  The configured getblk implementation is responsible for\n setting the final 3 fields when called (and/or when XD3_GETSRCBLK\n is returned)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_source {
    #[doc = " block size"]
    pub blksize: usize_t,
    #[doc = " its name, for debug/print\npurposes"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " opaque handle"]
    pub ioh: *mut ::std::os::raw::c_void,
    #[doc = " maximum visible buffer"]
    pub max_winsize: xoff_t,
    #[doc = " current block number: client\nsets after getblk request"]
    pub curblkno: xoff_t,
    #[doc = " number of bytes on current\nblock: client sets,  must be >= 0\nand <= blksize"]
    pub onblk: usize_t,
    #[doc = " current block array: client\nsets after getblk request"]
    pub curblk: *const u8,
    #[doc = " length of this source window"]
    pub srclen: usize_t,
    #[doc = " offset of this source window\nin the source itself"]
    pub srcbase: xoff_t,
    #[doc = " for power-of-two blocksizes"]
    pub shiftby: ::std::os::raw::c_int,
    #[doc = " for power-of-two blocksizes"]
    pub maskby: ::std::os::raw::c_int,
    #[doc = " offset of dec_cpyoff in blocks"]
    pub cpyoff_blocks: xoff_t,
    #[doc = " offset of copy window in\nblocks, remainder"]
    pub cpyoff_blkoff: usize_t,
    #[doc = " request block number: xd3 sets\ncurrent getblk request"]
    pub getblkno: xoff_t,
    #[doc = " Maximum block, if eof is known,\n otherwise, equals frontier_blkno\n (initially 0)."]
    pub max_blkno: xoff_t,
    #[doc = " Number of bytes on max_blkno"]
    pub onlastblk: usize_t,
    #[doc = " Set to true when the first\n partial block is read."]
    pub eof_known: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_source"][::std::mem::size_of::<_xd3_source>() - 120usize];
    ["Alignment of _xd3_source"][::std::mem::align_of::<_xd3_source>() - 8usize];
    ["Offset of field: _xd3_source::blksize"]
        [::std::mem::offset_of!(_xd3_source, blksize) - 0usize];
    ["Offset of field: _xd3_source::name"][::std::mem::offset_of!(_xd3_source, name) - 8usize];
    ["Offset of field: _xd3_source::ioh"][::std::mem::offset_of!(_xd3_source, ioh) - 16usize];
    ["Offset of field: _xd3_source::max_winsize"]
        [::std::mem::offset_of!(_xd3_source, max_winsize) - 24usize];
    ["Offset of field: _xd3_source::curblkno"]
        [::std::mem::offset_of!(_xd3_source, curblkno) - 32usize];
    ["Offset of field: _xd3_source::onblk"][::std::mem::offset_of!(_xd3_source, onblk) - 40usize];
    ["Offset of field: _xd3_source::curblk"][::std::mem::offset_of!(_xd3_source, curblk) - 48usize];
    ["Offset of field: _xd3_source::srclen"][::std::mem::offset_of!(_xd3_source, srclen) - 56usize];
    ["Offset of field: _xd3_source::srcbase"]
        [::std::mem::offset_of!(_xd3_source, srcbase) - 64usize];
    ["Offset of field: _xd3_source::shiftby"]
        [::std::mem::offset_of!(_xd3_source, shiftby) - 72usize];
    ["Offset of field: _xd3_source::maskby"][::std::mem::offset_of!(_xd3_source, maskby) - 76usize];
    ["Offset of field: _xd3_source::cpyoff_blocks"]
        [::std::mem::offset_of!(_xd3_source, cpyoff_blocks) - 80usize];
    ["Offset of field: _xd3_source::cpyoff_blkoff"]
        [::std::mem::offset_of!(_xd3_source, cpyoff_blkoff) - 88usize];
    ["Offset of field: _xd3_source::getblkno"]
        [::std::mem::offset_of!(_xd3_source, getblkno) - 96usize];
    ["Offset of field: _xd3_source::max_blkno"]
        [::std::mem::offset_of!(_xd3_source, max_blkno) - 104usize];
    ["Offset of field: _xd3_source::onlastblk"]
        [::std::mem::offset_of!(_xd3_source, onlastblk) - 112usize];
    ["Offset of field: _xd3_source::eof_known"]
        [::std::mem::offset_of!(_xd3_source, eof_known) - 116usize];
};
#[doc = " The primary xd3_stream object, used for encoding and decoding.  You\n may access only two fields: avail_out, next_out.  Use the methods\n above to operate on xd3_stream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xd3_stream {
    #[doc = " next input byte"]
    pub next_in: *const u8,
    #[doc = " number of bytes available at\nnext_in"]
    pub avail_in: usize_t,
    #[doc = " how many bytes in"]
    pub total_in: xoff_t,
    #[doc = " next output byte"]
    pub next_out: *mut u8,
    #[doc = " number of bytes available at\nnext_out"]
    pub avail_out: usize_t,
    #[doc = " total out space"]
    pub space_out: usize_t,
    #[doc = " number of windows encoded/decoded"]
    pub current_window: xoff_t,
    #[doc = " how many bytes out"]
    pub total_out: xoff_t,
    #[doc = " last error message, NULL if\nno error"]
    pub msg: *const ::std::os::raw::c_char,
    #[doc = " source array"]
    pub src: *mut xd3_source,
    #[doc = " suggested window size"]
    pub winsize: usize_t,
    #[doc = " small string, previous window\nsize (power of 2)"]
    pub sprevsz: usize_t,
    #[doc = " small string, previous window\nsize mask"]
    pub sprevmask: usize_t,
    pub iopt_size: usize_t,
    pub iopt_unlimited: usize_t,
    #[doc = " set nxtblk, nxtblkno to scanblkno"]
    pub getblk: xd3_getblk_func,
    #[doc = " malloc function"]
    pub alloc: xd3_alloc_func,
    #[doc = " free function"]
    pub free: xd3_free_func,
    #[doc = " private data object passed to\nalloc, free, and getblk"]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " various options"]
    pub flags: ::std::os::raw::c_int,
    #[doc = " Secondary compressor config: data"]
    pub sec_data: xd3_sec_cfg,
    #[doc = " Secondary compressor config: inst"]
    pub sec_inst: xd3_sec_cfg,
    #[doc = " Secondary compressor config: addr"]
    pub sec_addr: xd3_sec_cfg,
    pub smatcher: xd3_smatcher,
    #[doc = " table of large checksums"]
    pub large_table: *mut usize_t,
    #[doc = " large hash config"]
    pub large_hash: xd3_hash_cfg,
    #[doc = " table of small checksums"]
    pub small_table: *mut usize_t,
    #[doc = " table of previous offsets,\ncircular linked list"]
    pub small_prev: *mut xd3_slist,
    #[doc = " true if small table should\nbe reset"]
    pub small_reset: ::std::os::raw::c_int,
    #[doc = " small hash config"]
    pub small_hash: xd3_hash_cfg,
    #[doc = " the vcdiff address cache"]
    pub acache: xd3_addr_cache,
    #[doc = " state of the encoder"]
    pub enc_state: xd3_encode_state,
    #[doc = " base offset of the target input"]
    pub taroff: usize_t,
    #[doc = " current input position"]
    pub input_position: usize_t,
    #[doc = " current minimum match\nlength, avoids redundent\nmatches"]
    pub min_match: usize_t,
    #[doc = " current input, first\n unencoded offset. this value\n is <= the first instruction's\n position in the iopt buffer,\n if there is at least one\n match in the buffer."]
    pub unencoded_offset: usize_t,
    #[doc = " boolean: true if srclen and\nsrcbase have been\ndecided."]
    pub srcwin_decided: ::std::os::raw::c_int,
    #[doc = " boolean: true if srclen\nand srcbase were\ndecided early."]
    pub srcwin_decided_early: ::std::os::raw::c_int,
    #[doc = " Source checksum position"]
    pub srcwin_cksum_pos: xoff_t,
    #[doc = " encoder match state"]
    pub match_state: xd3_match_state,
    #[doc = " current match source\nposition relative to\nsrcbase"]
    pub match_srcpos: xoff_t,
    #[doc = " previously attempted\n srcpos, to avoid loops."]
    pub match_last_srcpos: xoff_t,
    #[doc = " smallest matching address to\n set window params (reset each\n window xd3_encode_reset)"]
    pub match_minaddr: xoff_t,
    #[doc = " largest matching address to\n set window params (reset each\n window xd3_encode_reset)"]
    pub match_maxaddr: xoff_t,
    #[doc = " match extends back so far"]
    pub match_back: usize_t,
    #[doc = " match extends back maximum"]
    pub match_maxback: usize_t,
    #[doc = " match extends forward so far"]
    pub match_fwd: usize_t,
    #[doc = " match extends forward maximum"]
    pub match_maxfwd: usize_t,
    #[doc = " address of the last source\nmatch (across windows)"]
    pub maxsrcaddr: xoff_t,
    #[doc = " for saving buffered input"]
    pub buf_in: *mut u8,
    #[doc = " amount of saved input"]
    pub buf_avail: usize_t,
    #[doc = " leftover content of next_in\n(i.e., user's buffer)"]
    pub buf_leftover: *const u8,
    #[doc = " amount of leftover content"]
    pub buf_leftavail: usize_t,
    #[doc = " current output buffer"]
    pub enc_current: *mut xd3_output,
    #[doc = " free output buffers"]
    pub enc_free: *mut xd3_output,
    #[doc = " array of encoded outputs:\nhead of chain"]
    pub enc_heads: [*mut xd3_output; 4usize],
    #[doc = " array of encoded outputs:\ntail of chain"]
    pub enc_tails: [*mut xd3_output; 4usize],
    #[doc = " set the adler32 checksum\n during \"recode\"."]
    pub recode_adler32: u32,
    #[doc = " instruction optimizing buffer"]
    pub iopt_used: xd3_rlist,
    pub iopt_free: xd3_rlist,
    #[doc = " next single instruction"]
    pub iout: *mut xd3_rinst,
    pub iopt_alloc: *mut xd3_iopt_buflist,
    #[doc = " application header to encode"]
    pub enc_appheader: *const u8,
    #[doc = " application header size"]
    pub enc_appheadsz: usize_t,
    #[doc = " current DEC_XXX value"]
    pub dec_state: xd3_decode_state,
    #[doc = " VCDIFF header indicator"]
    pub dec_hdr_ind: usize_t,
    #[doc = " VCDIFF window indicator"]
    pub dec_win_ind: usize_t,
    #[doc = " VCDIFF delta indicator"]
    pub dec_del_ind: usize_t,
    #[doc = " First four bytes"]
    pub dec_magic: [u8; 4usize],
    #[doc = " Magic position."]
    pub dec_magicbytes: usize_t,
    #[doc = " Optional secondary compressor ID."]
    pub dec_secondid: usize_t,
    #[doc = " Optional code table: length."]
    pub dec_codetblsz: u32,
    #[doc = " Optional code table: storage."]
    pub dec_codetbl: *mut u8,
    #[doc = " Optional code table: position."]
    pub dec_codetblbytes: usize_t,
    #[doc = " Optional application header:\nsize."]
    pub dec_appheadsz: u32,
    #[doc = " Optional application header:\nstorage"]
    pub dec_appheader: *mut u8,
    #[doc = " Optional application header:\nposition."]
    pub dec_appheadbytes: usize_t,
    #[doc = " Optional checksum: position."]
    pub dec_cksumbytes: usize_t,
    #[doc = " Optional checksum: storage."]
    pub dec_cksum: [u8; 4usize],
    #[doc = " Optional checksum: value."]
    pub dec_adler32: u32,
    #[doc = " length of copy window\n(VCD_SOURCE or VCD_TARGET)"]
    pub dec_cpylen: u32,
    #[doc = " offset of copy window\n(VCD_SOURCE or VCD_TARGET)"]
    pub dec_cpyoff: xoff_t,
    #[doc = " length of delta encoding"]
    pub dec_enclen: u32,
    #[doc = " length of target window"]
    pub dec_tgtlen: u32,
    #[doc = " part of a decoded uint64_t"]
    pub dec_64part: u64,
    #[doc = " part of a decoded uint32_t"]
    pub dec_32part: u32,
    #[doc = " offset of the start of\ncurrent target window"]
    pub dec_winstart: xoff_t,
    #[doc = " == current_window + 1 in\nDEC_FINISH"]
    pub dec_window_count: xoff_t,
    #[doc = " bytes of the three sections\nso far consumed"]
    pub dec_winbytes: usize_t,
    #[doc = " VCDIFF + app header size"]
    pub dec_hdrsize: usize_t,
    #[doc = " Base of decoded target\naddresses (addr >=\ndec_cpylen)."]
    pub dec_tgtaddrbase: *const u8,
    #[doc = " Base of decoded copy\naddresses (addr <\ndec_cpylen)."]
    pub dec_cpyaddrbase: *const u8,
    #[doc = " current decoder position\ncounting the cpylen\noffset"]
    pub dec_position: usize_t,
    #[doc = " maximum decoder position\ncounting the cpylen\noffset"]
    pub dec_maxpos: usize_t,
    #[doc = " current instruction"]
    pub dec_current1: xd3_hinst,
    #[doc = " current instruction"]
    pub dec_current2: xd3_hinst,
    #[doc = " Decode buffer"]
    pub dec_buffer: *mut u8,
    #[doc = " In case of VCD_TARGET, the\nlast target window."]
    pub dec_lastwin: *mut u8,
    #[doc = " length of the last target\nwindow"]
    pub dec_lastlen: usize_t,
    #[doc = " offset of the start of last\ntarget window"]
    pub dec_laststart: xoff_t,
    #[doc = " allocated space of last\ntarget window, for reuse"]
    pub dec_lastspace: usize_t,
    #[doc = " staging area for decoding\nwindow sections"]
    pub inst_sect: xd3_desect,
    pub addr_sect: xd3_desect,
    pub data_sect: xd3_desect,
    pub code_table_func: xd3_code_table_func,
    pub comp_table_func: xd3_comp_table_func,
    pub code_table: *const xd3_dinst,
    pub code_table_desc: *const xd3_code_table_desc,
    pub code_table_alloc: *mut xd3_dinst,
    #[doc = " secondary compression"]
    pub sec_type: *const xd3_sec_type,
    pub sec_stream_d: *mut xd3_sec_stream,
    pub sec_stream_i: *mut xd3_sec_stream,
    pub sec_stream_a: *mut xd3_sec_stream,
    #[doc = " state for reconstructing whole files (e.g., for merge), this only\n supports loading USIZE_T_MAX instructions, adds, etc."]
    pub whole_target: xd3_whole_state,
    #[doc = " statistics"]
    pub n_scpy: xoff_t,
    pub n_tcpy: xoff_t,
    pub n_add: xoff_t,
    pub n_run: xoff_t,
    pub l_scpy: xoff_t,
    pub l_tcpy: xoff_t,
    pub l_add: xoff_t,
    pub l_run: xoff_t,
    pub i_slots_used: usize_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xd3_stream"][::std::mem::size_of::<_xd3_stream>() - 1208usize];
    ["Alignment of _xd3_stream"][::std::mem::align_of::<_xd3_stream>() - 8usize];
    ["Offset of field: _xd3_stream::next_in"]
        [::std::mem::offset_of!(_xd3_stream, next_in) - 0usize];
    ["Offset of field: _xd3_stream::avail_in"]
        [::std::mem::offset_of!(_xd3_stream, avail_in) - 8usize];
    ["Offset of field: _xd3_stream::total_in"]
        [::std::mem::offset_of!(_xd3_stream, total_in) - 16usize];
    ["Offset of field: _xd3_stream::next_out"]
        [::std::mem::offset_of!(_xd3_stream, next_out) - 24usize];
    ["Offset of field: _xd3_stream::avail_out"]
        [::std::mem::offset_of!(_xd3_stream, avail_out) - 32usize];
    ["Offset of field: _xd3_stream::space_out"]
        [::std::mem::offset_of!(_xd3_stream, space_out) - 36usize];
    ["Offset of field: _xd3_stream::current_window"]
        [::std::mem::offset_of!(_xd3_stream, current_window) - 40usize];
    ["Offset of field: _xd3_stream::total_out"]
        [::std::mem::offset_of!(_xd3_stream, total_out) - 48usize];
    ["Offset of field: _xd3_stream::msg"][::std::mem::offset_of!(_xd3_stream, msg) - 56usize];
    ["Offset of field: _xd3_stream::src"][::std::mem::offset_of!(_xd3_stream, src) - 64usize];
    ["Offset of field: _xd3_stream::winsize"]
        [::std::mem::offset_of!(_xd3_stream, winsize) - 72usize];
    ["Offset of field: _xd3_stream::sprevsz"]
        [::std::mem::offset_of!(_xd3_stream, sprevsz) - 76usize];
    ["Offset of field: _xd3_stream::sprevmask"]
        [::std::mem::offset_of!(_xd3_stream, sprevmask) - 80usize];
    ["Offset of field: _xd3_stream::iopt_size"]
        [::std::mem::offset_of!(_xd3_stream, iopt_size) - 84usize];
    ["Offset of field: _xd3_stream::iopt_unlimited"]
        [::std::mem::offset_of!(_xd3_stream, iopt_unlimited) - 88usize];
    ["Offset of field: _xd3_stream::getblk"][::std::mem::offset_of!(_xd3_stream, getblk) - 96usize];
    ["Offset of field: _xd3_stream::alloc"][::std::mem::offset_of!(_xd3_stream, alloc) - 104usize];
    ["Offset of field: _xd3_stream::free"][::std::mem::offset_of!(_xd3_stream, free) - 112usize];
    ["Offset of field: _xd3_stream::opaque"]
        [::std::mem::offset_of!(_xd3_stream, opaque) - 120usize];
    ["Offset of field: _xd3_stream::flags"][::std::mem::offset_of!(_xd3_stream, flags) - 128usize];
    ["Offset of field: _xd3_stream::sec_data"]
        [::std::mem::offset_of!(_xd3_stream, sec_data) - 132usize];
    ["Offset of field: _xd3_stream::sec_inst"]
        [::std::mem::offset_of!(_xd3_stream, sec_inst) - 148usize];
    ["Offset of field: _xd3_stream::sec_addr"]
        [::std::mem::offset_of!(_xd3_stream, sec_addr) - 164usize];
    ["Offset of field: _xd3_stream::smatcher"]
        [::std::mem::offset_of!(_xd3_stream, smatcher) - 184usize];
    ["Offset of field: _xd3_stream::large_table"]
        [::std::mem::offset_of!(_xd3_stream, large_table) - 232usize];
    ["Offset of field: _xd3_stream::large_hash"]
        [::std::mem::offset_of!(_xd3_stream, large_hash) - 240usize];
    ["Offset of field: _xd3_stream::small_table"]
        [::std::mem::offset_of!(_xd3_stream, small_table) - 256usize];
    ["Offset of field: _xd3_stream::small_prev"]
        [::std::mem::offset_of!(_xd3_stream, small_prev) - 264usize];
    ["Offset of field: _xd3_stream::small_reset"]
        [::std::mem::offset_of!(_xd3_stream, small_reset) - 272usize];
    ["Offset of field: _xd3_stream::small_hash"]
        [::std::mem::offset_of!(_xd3_stream, small_hash) - 276usize];
    ["Offset of field: _xd3_stream::acache"]
        [::std::mem::offset_of!(_xd3_stream, acache) - 288usize];
    ["Offset of field: _xd3_stream::enc_state"]
        [::std::mem::offset_of!(_xd3_stream, enc_state) - 320usize];
    ["Offset of field: _xd3_stream::taroff"]
        [::std::mem::offset_of!(_xd3_stream, taroff) - 324usize];
    ["Offset of field: _xd3_stream::input_position"]
        [::std::mem::offset_of!(_xd3_stream, input_position) - 328usize];
    ["Offset of field: _xd3_stream::min_match"]
        [::std::mem::offset_of!(_xd3_stream, min_match) - 332usize];
    ["Offset of field: _xd3_stream::unencoded_offset"]
        [::std::mem::offset_of!(_xd3_stream, unencoded_offset) - 336usize];
    ["Offset of field: _xd3_stream::srcwin_decided"]
        [::std::mem::offset_of!(_xd3_stream, srcwin_decided) - 340usize];
    ["Offset of field: _xd3_stream::srcwin_decided_early"]
        [::std::mem::offset_of!(_xd3_stream, srcwin_decided_early) - 344usize];
    ["Offset of field: _xd3_stream::srcwin_cksum_pos"]
        [::std::mem::offset_of!(_xd3_stream, srcwin_cksum_pos) - 352usize];
    ["Offset of field: _xd3_stream::match_state"]
        [::std::mem::offset_of!(_xd3_stream, match_state) - 360usize];
    ["Offset of field: _xd3_stream::match_srcpos"]
        [::std::mem::offset_of!(_xd3_stream, match_srcpos) - 368usize];
    ["Offset of field: _xd3_stream::match_last_srcpos"]
        [::std::mem::offset_of!(_xd3_stream, match_last_srcpos) - 376usize];
    ["Offset of field: _xd3_stream::match_minaddr"]
        [::std::mem::offset_of!(_xd3_stream, match_minaddr) - 384usize];
    ["Offset of field: _xd3_stream::match_maxaddr"]
        [::std::mem::offset_of!(_xd3_stream, match_maxaddr) - 392usize];
    ["Offset of field: _xd3_stream::match_back"]
        [::std::mem::offset_of!(_xd3_stream, match_back) - 400usize];
    ["Offset of field: _xd3_stream::match_maxback"]
        [::std::mem::offset_of!(_xd3_stream, match_maxback) - 404usize];
    ["Offset of field: _xd3_stream::match_fwd"]
        [::std::mem::offset_of!(_xd3_stream, match_fwd) - 408usize];
    ["Offset of field: _xd3_stream::match_maxfwd"]
        [::std::mem::offset_of!(_xd3_stream, match_maxfwd) - 412usize];
    ["Offset of field: _xd3_stream::maxsrcaddr"]
        [::std::mem::offset_of!(_xd3_stream, maxsrcaddr) - 416usize];
    ["Offset of field: _xd3_stream::buf_in"]
        [::std::mem::offset_of!(_xd3_stream, buf_in) - 424usize];
    ["Offset of field: _xd3_stream::buf_avail"]
        [::std::mem::offset_of!(_xd3_stream, buf_avail) - 432usize];
    ["Offset of field: _xd3_stream::buf_leftover"]
        [::std::mem::offset_of!(_xd3_stream, buf_leftover) - 440usize];
    ["Offset of field: _xd3_stream::buf_leftavail"]
        [::std::mem::offset_of!(_xd3_stream, buf_leftavail) - 448usize];
    ["Offset of field: _xd3_stream::enc_current"]
        [::std::mem::offset_of!(_xd3_stream, enc_current) - 456usize];
    ["Offset of field: _xd3_stream::enc_free"]
        [::std::mem::offset_of!(_xd3_stream, enc_free) - 464usize];
    ["Offset of field: _xd3_stream::enc_heads"]
        [::std::mem::offset_of!(_xd3_stream, enc_heads) - 472usize];
    ["Offset of field: _xd3_stream::enc_tails"]
        [::std::mem::offset_of!(_xd3_stream, enc_tails) - 504usize];
    ["Offset of field: _xd3_stream::recode_adler32"]
        [::std::mem::offset_of!(_xd3_stream, recode_adler32) - 536usize];
    ["Offset of field: _xd3_stream::iopt_used"]
        [::std::mem::offset_of!(_xd3_stream, iopt_used) - 544usize];
    ["Offset of field: _xd3_stream::iopt_free"]
        [::std::mem::offset_of!(_xd3_stream, iopt_free) - 560usize];
    ["Offset of field: _xd3_stream::iout"][::std::mem::offset_of!(_xd3_stream, iout) - 576usize];
    ["Offset of field: _xd3_stream::iopt_alloc"]
        [::std::mem::offset_of!(_xd3_stream, iopt_alloc) - 584usize];
    ["Offset of field: _xd3_stream::enc_appheader"]
        [::std::mem::offset_of!(_xd3_stream, enc_appheader) - 592usize];
    ["Offset of field: _xd3_stream::enc_appheadsz"]
        [::std::mem::offset_of!(_xd3_stream, enc_appheadsz) - 600usize];
    ["Offset of field: _xd3_stream::dec_state"]
        [::std::mem::offset_of!(_xd3_stream, dec_state) - 604usize];
    ["Offset of field: _xd3_stream::dec_hdr_ind"]
        [::std::mem::offset_of!(_xd3_stream, dec_hdr_ind) - 608usize];
    ["Offset of field: _xd3_stream::dec_win_ind"]
        [::std::mem::offset_of!(_xd3_stream, dec_win_ind) - 612usize];
    ["Offset of field: _xd3_stream::dec_del_ind"]
        [::std::mem::offset_of!(_xd3_stream, dec_del_ind) - 616usize];
    ["Offset of field: _xd3_stream::dec_magic"]
        [::std::mem::offset_of!(_xd3_stream, dec_magic) - 620usize];
    ["Offset of field: _xd3_stream::dec_magicbytes"]
        [::std::mem::offset_of!(_xd3_stream, dec_magicbytes) - 624usize];
    ["Offset of field: _xd3_stream::dec_secondid"]
        [::std::mem::offset_of!(_xd3_stream, dec_secondid) - 628usize];
    ["Offset of field: _xd3_stream::dec_codetblsz"]
        [::std::mem::offset_of!(_xd3_stream, dec_codetblsz) - 632usize];
    ["Offset of field: _xd3_stream::dec_codetbl"]
        [::std::mem::offset_of!(_xd3_stream, dec_codetbl) - 640usize];
    ["Offset of field: _xd3_stream::dec_codetblbytes"]
        [::std::mem::offset_of!(_xd3_stream, dec_codetblbytes) - 648usize];
    ["Offset of field: _xd3_stream::dec_appheadsz"]
        [::std::mem::offset_of!(_xd3_stream, dec_appheadsz) - 652usize];
    ["Offset of field: _xd3_stream::dec_appheader"]
        [::std::mem::offset_of!(_xd3_stream, dec_appheader) - 656usize];
    ["Offset of field: _xd3_stream::dec_appheadbytes"]
        [::std::mem::offset_of!(_xd3_stream, dec_appheadbytes) - 664usize];
    ["Offset of field: _xd3_stream::dec_cksumbytes"]
        [::std::mem::offset_of!(_xd3_stream, dec_cksumbytes) - 668usize];
    ["Offset of field: _xd3_stream::dec_cksum"]
        [::std::mem::offset_of!(_xd3_stream, dec_cksum) - 672usize];
    ["Offset of field: _xd3_stream::dec_adler32"]
        [::std::mem::offset_of!(_xd3_stream, dec_adler32) - 676usize];
    ["Offset of field: _xd3_stream::dec_cpylen"]
        [::std::mem::offset_of!(_xd3_stream, dec_cpylen) - 680usize];
    ["Offset of field: _xd3_stream::dec_cpyoff"]
        [::std::mem::offset_of!(_xd3_stream, dec_cpyoff) - 688usize];
    ["Offset of field: _xd3_stream::dec_enclen"]
        [::std::mem::offset_of!(_xd3_stream, dec_enclen) - 696usize];
    ["Offset of field: _xd3_stream::dec_tgtlen"]
        [::std::mem::offset_of!(_xd3_stream, dec_tgtlen) - 700usize];
    ["Offset of field: _xd3_stream::dec_64part"]
        [::std::mem::offset_of!(_xd3_stream, dec_64part) - 704usize];
    ["Offset of field: _xd3_stream::dec_32part"]
        [::std::mem::offset_of!(_xd3_stream, dec_32part) - 712usize];
    ["Offset of field: _xd3_stream::dec_winstart"]
        [::std::mem::offset_of!(_xd3_stream, dec_winstart) - 720usize];
    ["Offset of field: _xd3_stream::dec_window_count"]
        [::std::mem::offset_of!(_xd3_stream, dec_window_count) - 728usize];
    ["Offset of field: _xd3_stream::dec_winbytes"]
        [::std::mem::offset_of!(_xd3_stream, dec_winbytes) - 736usize];
    ["Offset of field: _xd3_stream::dec_hdrsize"]
        [::std::mem::offset_of!(_xd3_stream, dec_hdrsize) - 740usize];
    ["Offset of field: _xd3_stream::dec_tgtaddrbase"]
        [::std::mem::offset_of!(_xd3_stream, dec_tgtaddrbase) - 744usize];
    ["Offset of field: _xd3_stream::dec_cpyaddrbase"]
        [::std::mem::offset_of!(_xd3_stream, dec_cpyaddrbase) - 752usize];
    ["Offset of field: _xd3_stream::dec_position"]
        [::std::mem::offset_of!(_xd3_stream, dec_position) - 760usize];
    ["Offset of field: _xd3_stream::dec_maxpos"]
        [::std::mem::offset_of!(_xd3_stream, dec_maxpos) - 764usize];
    ["Offset of field: _xd3_stream::dec_current1"]
        [::std::mem::offset_of!(_xd3_stream, dec_current1) - 768usize];
    ["Offset of field: _xd3_stream::dec_current2"]
        [::std::mem::offset_of!(_xd3_stream, dec_current2) - 780usize];
    ["Offset of field: _xd3_stream::dec_buffer"]
        [::std::mem::offset_of!(_xd3_stream, dec_buffer) - 792usize];
    ["Offset of field: _xd3_stream::dec_lastwin"]
        [::std::mem::offset_of!(_xd3_stream, dec_lastwin) - 800usize];
    ["Offset of field: _xd3_stream::dec_lastlen"]
        [::std::mem::offset_of!(_xd3_stream, dec_lastlen) - 808usize];
    ["Offset of field: _xd3_stream::dec_laststart"]
        [::std::mem::offset_of!(_xd3_stream, dec_laststart) - 816usize];
    ["Offset of field: _xd3_stream::dec_lastspace"]
        [::std::mem::offset_of!(_xd3_stream, dec_lastspace) - 824usize];
    ["Offset of field: _xd3_stream::inst_sect"]
        [::std::mem::offset_of!(_xd3_stream, inst_sect) - 832usize];
    ["Offset of field: _xd3_stream::addr_sect"]
        [::std::mem::offset_of!(_xd3_stream, addr_sect) - 888usize];
    ["Offset of field: _xd3_stream::data_sect"]
        [::std::mem::offset_of!(_xd3_stream, data_sect) - 944usize];
    ["Offset of field: _xd3_stream::code_table_func"]
        [::std::mem::offset_of!(_xd3_stream, code_table_func) - 1000usize];
    ["Offset of field: _xd3_stream::comp_table_func"]
        [::std::mem::offset_of!(_xd3_stream, comp_table_func) - 1008usize];
    ["Offset of field: _xd3_stream::code_table"]
        [::std::mem::offset_of!(_xd3_stream, code_table) - 1016usize];
    ["Offset of field: _xd3_stream::code_table_desc"]
        [::std::mem::offset_of!(_xd3_stream, code_table_desc) - 1024usize];
    ["Offset of field: _xd3_stream::code_table_alloc"]
        [::std::mem::offset_of!(_xd3_stream, code_table_alloc) - 1032usize];
    ["Offset of field: _xd3_stream::sec_type"]
        [::std::mem::offset_of!(_xd3_stream, sec_type) - 1040usize];
    ["Offset of field: _xd3_stream::sec_stream_d"]
        [::std::mem::offset_of!(_xd3_stream, sec_stream_d) - 1048usize];
    ["Offset of field: _xd3_stream::sec_stream_i"]
        [::std::mem::offset_of!(_xd3_stream, sec_stream_i) - 1056usize];
    ["Offset of field: _xd3_stream::sec_stream_a"]
        [::std::mem::offset_of!(_xd3_stream, sec_stream_a) - 1064usize];
    ["Offset of field: _xd3_stream::whole_target"]
        [::std::mem::offset_of!(_xd3_stream, whole_target) - 1072usize];
    ["Offset of field: _xd3_stream::n_scpy"]
        [::std::mem::offset_of!(_xd3_stream, n_scpy) - 1136usize];
    ["Offset of field: _xd3_stream::n_tcpy"]
        [::std::mem::offset_of!(_xd3_stream, n_tcpy) - 1144usize];
    ["Offset of field: _xd3_stream::n_add"][::std::mem::offset_of!(_xd3_stream, n_add) - 1152usize];
    ["Offset of field: _xd3_stream::n_run"][::std::mem::offset_of!(_xd3_stream, n_run) - 1160usize];
    ["Offset of field: _xd3_stream::l_scpy"]
        [::std::mem::offset_of!(_xd3_stream, l_scpy) - 1168usize];
    ["Offset of field: _xd3_stream::l_tcpy"]
        [::std::mem::offset_of!(_xd3_stream, l_tcpy) - 1176usize];
    ["Offset of field: _xd3_stream::l_add"][::std::mem::offset_of!(_xd3_stream, l_add) - 1184usize];
    ["Offset of field: _xd3_stream::l_run"][::std::mem::offset_of!(_xd3_stream, l_run) - 1192usize];
    ["Offset of field: _xd3_stream::i_slots_used"]
        [::std::mem::offset_of!(_xd3_stream, i_slots_used) - 1200usize];
};
unsafe extern "C" {
    #[doc = " This function configures an xd3_stream using the provided in-memory\n input buffer, source buffer, output buffer, and flags.  The output\n array must be large enough or else ENOSPC will be returned.  This\n is the simplest in-memory encoding interface."]
    pub fn xd3_encode_memory(
        input: *const u8,
        input_size: usize_t,
        source: *const u8,
        source_size: usize_t,
        output_buffer: *mut u8,
        output_size: *mut usize_t,
        avail_output: usize_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The reverse of xd3_encode_memory."]
    pub fn xd3_decode_memory(
        input: *const u8,
        input_size: usize_t,
        source: *const u8,
        source_size: usize_t,
        output_buf: *mut u8,
        output_size: *mut usize_t,
        avail_output: usize_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " This function encodes an in-memory input using a pre-configured\n xd3_stream.  This allows the caller to set a variety of options\n which are not available in the xd3_encode/decode_memory()\n functions.\n\n The output array must be large enough to hold the output or else\n ENOSPC is returned.  The source (if any) should be set using\n xd3_set_source_and_size() with a single-block xd3_source.  This\n calls the underlying non-blocking interfaces,\n xd3_encode/decode_input(), handling the necessary input/output\n states.  This method may be considered a reference for any\n application using xd3_encode_input() directly.\n\n   xd3_stream stream;\n   xd3_config config;\n   xd3_source src;\n\n   memset (& src, 0, sizeof (src));\n   memset (& stream, 0, sizeof (stream));\n   memset (& config, 0, sizeof (config));\n\n   if (source != NULL)\n     {\n       src.size = source_size;\n       src.blksize = source_size;\n       src.curblkno = 0;\n       src.onblk = source_size;\n       src.curblk = source;\n       src.max_winsize = source_size;\n       xd3_set_source(&stream, &src);\n     }\n\n   config.flags = flags;\n   config.winsize = input_size;\n\n   ... set smatcher, appheader, encoding-table, compression-level, etc.\n\n   xd3_config_stream(&stream, &config);\n   xd3_encode_stream(&stream, ...);\n   xd3_free_stream(&stream);"]
    pub fn xd3_encode_stream(
        stream: *mut xd3_stream,
        input: *const u8,
        input_size: usize_t,
        output: *mut u8,
        output_size: *mut usize_t,
        avail_output: usize_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The reverse of xd3_encode_stream."]
    pub fn xd3_decode_stream(
        stream: *mut xd3_stream,
        input: *const u8,
        input_size: usize_t,
        output: *mut u8,
        output_size: *mut usize_t,
        avail_size: usize_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " This is the non-blocking interface.\n\n Handling input and output states is the same for encoding or\n decoding using the xd3_avail_input() and xd3_consume_output()\n routines, inlined below.\n\n Return values:\n\n   XD3_INPUT: the process requires more input: call\n               xd3_avail_input() then repeat\n\n   XD3_OUTPUT: the process has more output: read stream->next_out,\n               stream->avail_out, then call xd3_consume_output(),\n               then repeat\n\n   XD3_GOTHEADER: (decoder-only) notification returned following the\n               VCDIFF header and first window header.  the decoder\n               may use the header to configure itself.\n\n   XD3_WINSTART: a general notification returned once for each\n               window except the 0-th window, which is implied by\n               XD3_GOTHEADER.  It is recommended to use a\n               switch-stmt such as:\n\n                 ...\n               again:\n                 switch ((ret = xd3_decode_input (stream))) {\n                    case XD3_GOTHEADER: {\n                      assert(stream->current_window == 0);\n                      stuff;\n                    }\n                    // fallthrough\n                    case XD3_WINSTART: {\n                      something(stream->current_window);\n                      goto again;\n                    }\n                    ...\n\n   XD3_WINFINISH: a general notification, following the complete\n               input & output of a window.  at this point,\n               stream->total_in and stream->total_out are consistent\n               for either encoding or decoding.\n\n   XD3_GETSRCBLK: If the xd3_getblk() callback is NULL, this value\n               is returned to initiate a non-blocking source read."]
    pub fn xd3_decode_input(stream: *mut xd3_stream) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xd3_encode_input(stream: *mut xd3_stream) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The xd3_config structure is used to initialize a stream - all data\n is copied into stream so config may be a temporary variable.  See\n the [documentation] or comments on the xd3_config structure."]
    pub fn xd3_config_stream(
        stream: *mut xd3_stream,
        config: *mut xd3_config,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Since Xdelta3 doesn't open any files, xd3_close_stream is just an\n error check that the stream is in a proper state to be closed: this\n means the encoder is flushed and the decoder is at a window\n boundary.  The application is responsible for freeing any of the\n resources it supplied."]
    pub fn xd3_close_stream(stream: *mut xd3_stream) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " This arranges for closes the stream to succeed.  Does not free the\n stream."]
    pub fn xd3_abort_stream(stream: *mut xd3_stream);
}
unsafe extern "C" {
    #[doc = " xd3_free_stream frees all memory allocated for the stream.  The\n application is responsible for freeing any of the resources it\n supplied."]
    pub fn xd3_free_stream(stream: *mut xd3_stream);
}
unsafe extern "C" {
    #[doc = " This function informs the encoder or decoder that source matching\n (i.e., delta-compression) is possible.  For encoding, this should\n be called before the first xd3_encode_input.  A NULL source is\n ignored.  For decoding, this should be called before the first\n window is decoded, but the appheader may be read first\n (XD3_GOTHEADER).  After decoding the header, call xd3_set_source()\n if you have a source file.  Note: if (stream->dec_win_ind & VCD_SOURCE)\n is true, it means the first window expects there to be a source file."]
    pub fn xd3_set_source(
        stream: *mut xd3_stream,
        source: *mut xd3_source,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " If the source size is known, call this instead of xd3_set_source().\n to avoid having stream->getblk called (and/or to avoid XD3_GETSRCBLK).\n\n Follow these steps:\nxd3_source source;\nmemset(&source, 0, sizeof(source));\nsource.blksize  = size;\nsource.onblk    = size;\nsource.curblk   = buf;\nsource.curblkno = 0;\nint ret = xd3_set_source_and_size(&stream, &source, size);\n..."]
    pub fn xd3_set_source_and_size(
        stream: *mut xd3_stream,
        source: *mut xd3_source,
        source_size: xoff_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " This should be called before the first call to xd3_encode_input()\n to include application-specific data in the VCDIFF header."]
    pub fn xd3_set_appheader(stream: *mut xd3_stream, data: *const u8, size: usize_t);
}
unsafe extern "C" {
    #[doc = " xd3_get_appheader may be called in the decoder after XD3_GOTHEADER.\n For convenience, the decoder always adds a single byte padding to\n the end of the application header, which is set to zero in case the\n application header is a string."]
    pub fn xd3_get_appheader(
        stream: *mut xd3_stream,
        data: *mut *mut u8,
        size: *mut usize_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " To generate a VCDIFF encoded delta with xd3_encode_init() from\n another format, use:\n\n   xd3_encode_init_partial() -- initialze encoder state (w/o hash tables)\n   xd3_init_cache() -- reset VCDIFF address cache\n   xd3_found_match() -- to report a copy instruction\n\n set stream->enc_state to ENC_INSTR and call xd3_encode_input as usual."]
    pub fn xd3_encode_init_partial(stream: *mut xd3_stream) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xd3_init_cache(acache: *mut xd3_addr_cache);
}
unsafe extern "C" {
    pub fn xd3_found_match(
        stream: *mut xd3_stream,
        pos: usize_t,
        size: usize_t,
        addr: xoff_t,
        is_source: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gives an error string for xdelta3-speficic errors, returns NULL for\nsystem errors"]
    pub fn xd3_strerror(ret: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
